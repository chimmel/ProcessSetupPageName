<?php

/**
 * 
 * made by kixe (Christoph Thelen) 15.12.15
 * Licensed under GNU/GPL v3
 * 
 * ProcessWire 2.x 
 * Copyright (C) 2015 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 * @todo add configuration option to handle datetime fields. How to make this module configurable ???
 * provide 2 more options in module settings (unformatted = -1, specified format like 'y-m-d')
 * if unformatted $value = $page->getUnformatted($format);
 * workaround: for now we convert timestamp to format corresponding to field settings (dateOutputFormat) as default
 *
 */

class ProcessSetupPageName extends Pages implements Module {

	public static function getModuleInfo() {
		return array(
			'title' => __('Setup Page Name'), 
			'version' => 201, 
			'summary' => __("Overwrites function setupPageName() in class Pages (core), which is typically called in case of autogeneration of pages. Provides more options for 'Name Format Children' in parent template settings"),
			'href' => 'https://processwire.com/talk/topic/8576-name-format-children/?p=108748',
			'author' => 'kixe',
			'singular' => true,
			'autoload' => true,
			'requires' => 'PHP>=5.4.0',
			);
	}

	/**
	 * constructor expected by PW 3.x
	 * thanks to Adrian
	 *
	 */
	public function __construct() {
	    // intentionally empty
	}

	/**
	 * Name for autogenerated page names when fields to generate name aren't populated
	 *
	 * @var string
	 *
	 */
	protected $untitledPageName = 'untitled';

	protected $languageSupport = false;

	private static $notes;

	/**
	 * add Hooks to Pages::setupPageName, ProcessTemplate::buildEditForm and InputfieldPageTable::getConfigInputfields
	 * 
	 *
	 */
	public function init() {
		$this->addHookBefore('Pages::setupPageName', function($event) {
			$page = $event->arguments[0];
			$event->replace = true;
			$options = count($event->arguments)==2?$event->arguments[1]:array();
			$name = wire('modules')->get('ProcessSetupPageName')->SetupPageName($page, $options);
    		$event->return = $name;
		});
		self::$notes = $this->_('Leave blank to disable. Enter any fieldname, subfield, property or date() function separated by space. Dot syntax allowed. Example: \'parent.title date(Y) myfield\' (without quotes) will auto-generate the name from the title of page parent, the current year and the value of pagefield \'myfield\' [More](https://processwire.com/talk/topic/8576-name-format-children/?p=108748)');	
		$this->addHookAfter('ProcessTemplate::buildEditForm', function($event) {
			$return = $event->return;
			$return->children()->get(2)->children()->first()->children()->get('childNameFormat')->set('notes',self::$notes);
			$event->return = $return;
		});
		if (wire('modules')->isInstalled('InputfieldPageTable')) {
			$this->addHookAfter('InputfieldPageTable::getConfigInputfields', function($event) {
				$return = $event->return;
				$return->children()->get('nameFormat')->set('notes',self::$notes);
				$event->return = $return;
			});
		}
		if ($this->wire('modules')->isInstalled('LanguageSupportPageNames')) {
			$this->languageSupport = true;
			$this->addHookBefore('Pages::saveReady', $this, 'hookSaveReady');
		}	
	}

	/**
	 * create a page name based on 'Name Format Children' in settings of parent page template
	 * 
	 * @param Page $page
	 * @param string $format use dot syntax if value has subfields or is an object
	 * spaces are detected as separator for properties, fields or date() function
	 * using space inside date() function will cause an error
     * @param int $languageID
	 * 
	 * @return string/ bool If a name was generated it is returned. false in case of error or warning
	 */
	public function createFromFormat(Page $page, $format, $languageID = null) {

		if ($languageID == null && $this->languageSupport == true) $languageID = wire('languages')->getDefault()->id;

		$format = trim($format, " \t\n\r,}{'\"");
		if (!$format) return false;	
		$error = false;
		$warning = false;
		$pageName = '';

		// case 1: multiple fields
		if (strpos($format,' ')) {
			// space not allowed in name so we can use it as separator
			$formats = explode(' ',$format);
			foreach ($formats as $_format) {
				$_format = trim($_format, " \t\n\r,}{'\"");
				if (!strlen($_format)) continue;
				$_pageName = $this->createFromFormat($page, $_format, $languageID); 
				if ($_pageName == false) return false;
				$pageName .= '-'.$_pageName;
			}
		}

		// case 2: title default
		else if ($format == 'title') {
			if (!$this->languageSupport) {
				$pageName .= '-'.$page->title;
			}
			else if (strlen($page->getLanguageValue($languageID, 'title'))) {
				$pageName .= '-'.$page->getLanguageValue($languageID, 'title');
			}
		}
			
		// case 3: date()
		else if (strpos($format, 'date(') === 0 ) {
			// we don't allow spaces inside date()
			if (preg_match('/(date\()([^)\s]+)(\))/',$format,$matches)) {
				$date = date($matches[2]);
				if (!strlen($date)) $error = true; // could this ever happen?
				else $pageName .= '-'.$date;
			}
			else {
				$format_error = $this->_("Error: 'Name Format Children' in settings of template '%s'. Unproper use of date() function. Missing closing bracket or unallowed space near: '%s'");
				$error = true;
			}
		}

		// case 4: string could be determined with $page->get() we take this
		else if (strlen($page->get($format))) {
			if ($this->languageSupport) {
				$userLang = wire('user')->language;
				wire('user')->language = wire('languages')->get($languageID);
			}
			if (wire('fields')->get($format)->type instanceof FieldtypeOptions) $value = $page->get($format)->title;
			else $value = $page->get($format);
			if (is_int($value) && $page->template->hasField($format) && wire('fields')->get($format)->type instanceof FieldtypeDatetime) {
				$dateOutputFormat = wire('fields')->get($format)->dateOutputFormat;
				// for now we convert timestamp to format corresponding to field settings (dateOutputFormat) as default
				$value = date($dateOutputFormat, $value);
			}
			$pageName .= '-'.$value;
			if ($this->languageSupport) wire('user')->language = $userLang;
		}

		// case 5: no value. check if field or subfield exists, set flag for warning or error and return false
		else {
			if (strpos($format,'.')) $_format = explode('.',$format);
			else $_format = array($format);
			if($page->template->hasField($_format[0])) {
				// one or more field values not populated
				if (count($_format) == 1) $warning = true;
				// field has subfields
				else if (count($_format) == 2) {
					$field = wire('fields')->get($_format[0]);
					$info = $field->type->getSelectorInfo($field);
					$subfields = array_keys($info['subfields']);
					if (!in_array($_format[1],$subfields)) $error = true;
					else $warning = true;
				}
				// todo check subsubfields for now we allow only subfields
				else $error = true;
				// prevent to show warning twice
				if (strpos($page->name, $this->untitledPageName) !== 0) $warning = false;
			}
			// field doesn't exist or isn't assigned to page template
			else $error = true;
		}			

		// output warning or error only in user language
		if ($this->languageSupport == false || wire('user')->language->id == $languageID) {
			$format_error = isset($format_error)?$format_error:$this->_("Error: 'Name Format Children' in settings of template '%s'. Unknown property, field or subfield: '%s'");
			if ($error === true) $this->error(sprintf($format_error, $page->parent->template->name, $format));
			$format_warning = $this->_("SetupPageName expects value in field '%s' to autogenerate Pagename");
			if ($warning === true) $this->warning(sprintf($format_warning, $format));
		}
		if (!$error && !$warning) return ltrim($pageName,'-');
		return false;

	}

	/**
	 * Overwrites same function in Core Class Pages
	 * Auto-assign a page name to this page
	 * 
	 * Typically this would be used only if page had no name or if it had a temporary untitled name.
	 * 
	 * Page will be populated with the name given. This method will not populate names to pages that
	 * already have a name, unless the name is "untitled"
	 * 
	 * @param Page $page
	 * @param array $options 
	 * 	- format: Optionally specify the format to use, or leave blank to auto-determine. Use title if set or datetime string
	 * 
	 * @return string If a name was generated it is returned. If no name was generated blank is returned.
	 * 
	 */
	public function ___SetupPageName(Page $page, array $options = array()) {

		$defaults = array(
			'format' => '', 
			);
		$options = array_merge($defaults, $options); 
		$format = $options['format']; 
		
		if(strlen($page->name)) {
			// make sure page starts with "untitled" or "untitled-"
			if($page->name != $this->untitledPageName && strpos($page->name, "$this->untitledPageName-") !== 0) {
				// page already has a name and it's not a temporary/untitled one
				// so we do nothing
				return '';
			}
			// page starts with our untitled name, but is it in the exact format we use?
			if($page->name != $this->untitledPageName) {
				$parts = explode('-', $page->name);
				array_shift($parts); // shift off 'untitled';
				$parts = implode('', $parts); // put remaining back together
				// if we were left with something other than digits, 
				// this is not an auto-generated name, so leave as-is
				if(!ctype_digit($parts)) return '';
			}
		}

		if(!strlen($format)) $format = $page->parent()->template->childNameFormat;
		if(!strlen($format)) {
			if(strlen($page->title)) {
				// default format is title
				$format = 'title';
			} else {
				// if page has no title, default format is date
				$format = 'date(Y-m-d-H-i-s)';
			}
		}
		
		$pageName = '';
		
		// childNameFormat is set
		if (strlen($format)) {
			$pageName = $this->createFromFormat($page,$format);
			if ($pageName == false) $pageName = $this->untitledPageName;
		}

		else if (strlen($page->title)) $pageName = $page->title;

		else {
			// no name will be assigned
			$pageName = '';
		}
		
		if($pageName == $this->untitledPageName && strpos($page->name, $this->untitledPageName) === 0) {
			// page already has untitled name, and there's no need to re-assign the untitled name
			return '';
		}

		if (strlen($pageName)) {
			$pageName = $this->sanitizePageName($pageName);
			$page->name = $this->makeUnique($pageName, $page->parent->id);		
			$page->set('_hasAutogenName', true); // for savePageQuery, provides adjustName behavior for new pages
			return $page->name;
		}

		return '';
	}

	/**
	 * 
	 * @param string $pageName
	 * @param int $parentID for local search, default global search
	 * @param int $languageID
	 * @return array of Page names in use matching $pageName with integer appendix -n
	 * 
	 */
	public function getSameNameArray($pageName, $parentID = 0, $languageID = null) {
		// Page Name Extended which allows UTF8 Page Names doesn't work properly!
		// first letter get cutted away of each item ???
		// $pageName = mb_convert_encoding($pageName,'ASCII');
		if ($languageID) {
			if (!wire('languages')->get($languageID)->id) throw new WireException("Cannot find language with ID $languageID");
			else if (wire('languages')->get($languageID)->isDefault()) $languageID = null;
		}
		$local = ($parentID && is_int($parentID))?" parent_id = $parentID AND":'';
		$sql = "SELECT name$languageID FROM pages WHERE$local name$languageID REGEXP '^($pageName)(-([[:digit:]]+))?$'";
		$query = wire('database')->prepare($sql);
		$this->executeQuery($query);
		$result = $query->fetchAll(PDO::FETCH_COLUMN);
		return $result;
	}

	/**
	 * create a unique (local or global) name with -n appendix
	 * index -n will be highest index of similar named pages +1
	 * 
	 * @param string $pageName
	 * @param int $parentID (uniquify locally under this parent)
	 * @param int $languageID
	 * @return string $pageName-n
	 * 
	 */
	public function makeUnique($pageName, $parentID = 0, $languageID = null) {
		$names = $this->getSameNameArray($pageName, $parentID, $languageID);
		if (empty($names) || !in_array($pageName,$names)) return $pageName;
		$indexes = array();
		foreach ($names as $name) {
			$indexes[] = trim(strrchr($name,'-'),'-');
		}
		$newindex = max($indexes)+1;
		if ($newindex == 1) $newindex = 2;
		if(strlen($pageName) + strlen($newindex) > self::nameMaxLength) $pageName = substr($pageName, 0, self::nameMaxLength - strlen($newindex));
		return "$pageName-$newindex";
	}

	/**
	 * Sanitize page name
	 * @param string $pagename
	 * @return string $pagename
	 */
	public function sanitizePageName($pageName) {
		if($this->wire('config')->pageNameCharset === 'UTF8') {
			$pageName = $this->wire('sanitizer')->pageNameUTF8($pageName);
		} else {
			$pageName = $this->wire('sanitizer')->pageName($pageName, Sanitizer::translate);
		}	
		return $pageName;
	}

	/**
	 * hook to assign language specific names
	 * run only if not already set (NULL) AND Inputfield _pw_page_name is cleared/empty
	 * 
	 */
    public function hookSaveReady($event) {
    	$page = $event->arguments[0];
    	$format = $page->parent()->template->childNameFormat;
    	if (!strlen($format)) return;
		$SetupPageName = wire('modules')->get('ProcessSetupPageName');
		foreach (wire('languages') as $language) {
			if ($language->isDefault()) continue;
			$pageLangName = $SetupPageName->sanitizePageName(wire('input')->post->{"_pw_page_name$language->id"});
			if (strpos($pageLangName, $SetupPageName->untitledPageName) !== 0 && $pageLangName == $page->name) continue;
			if ($page->{"name".$language->id}) continue;
			$pageLangName = $SetupPageName->createFromFormat($page, $format, $language->id);
			if (!$pageLangName) continue;
			$pageLangName = $SetupPageName->sanitizePageName($pageLangName);
			$pageLangName = $SetupPageName->makeUnique($pageLangName, $page->parent->id, $language->id);
			$page->{"name".$language->id} = $pageLangName;
		}
	}
}